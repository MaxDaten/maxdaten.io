---
phase: 02-vertical-slice
plan: 03
type: execute
wave: 3
depends_on: ['02-01', '02-02']
files_modified:
    - src/routes/[slug]/+page.server.ts
    - src/routes/[slug]/+page.svelte
    - src/routes/blog/+page.server.ts
    - src/lib/utils/types.ts
autonomous: true

must_haves:
    truths:
        - 'Sanity post loads when slug matches Sanity content'
        - 'Markdown post loads when slug not found in Sanity'
        - 'Blog listing shows merged posts from both sources sorted by date'
        - 'Sanity posts deduplicate markdown posts with same slug'
        - 'API failure shows error, not silent fallback'
    artifacts:
        - path: 'src/routes/[slug]/+page.server.ts'
          provides: 'Dual-source loading with Sanity-first'
          contains: "source: 'sanity'"
        - path: 'src/routes/[slug]/+page.svelte'
          provides: 'Conditional rendering for Sanity vs markdown'
          contains: 'PortableText'
        - path: 'src/routes/blog/+page.server.ts'
          provides: 'Merged blog listing'
          contains: 'sanityPosts'
    key_links:
        - from: 'src/routes/[slug]/+page.server.ts'
          to: '$lib/sanity/client.ts'
          via: 'client.fetch import'
          pattern: 'import.*client.*sanity'
        - from: 'src/routes/[slug]/+page.svelte'
          to: '@portabletext/svelte'
          via: 'PortableText component'
          pattern: 'import.*PortableText'
---

<objective>
Wire dual-source routing for blog posts and merged listing page.

Purpose: Enable the site to serve blog posts from either Sanity CMS or markdown files, with Sanity
taking priority. The blog listing merges both sources. This is the core integration that makes the
vertical slice work.

Output: Working dual-source routing where Sanity posts render with Portable Text and markdown posts
continue to work unchanged. </objective>

<execution_context> @./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md </execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-vertical-slice/02-CONTEXT.md
@.planning/phases/02-vertical-slice/02-RESEARCH.md
@.planning/phases/02-vertical-slice/02-01-SUMMARY.md
@.planning/phases/02-vertical-slice/02-02-SUMMARY.md

# Current implementations to modify

@src/routes/[slug]/+page.server.ts @src/routes/[slug]/+page.svelte @src/routes/blog/+page.server.ts
@src/lib/server/posts.ts @src/lib/utils/types.ts </context>

<tasks>

<task type="auto">
  <name>Task 1: Create dual-source loading in [slug] route</name>
  <files>src/routes/[slug]/+page.server.ts, src/lib/utils/types.ts</files>
  <action>
Update `src/lib/utils/types.ts`:
- Add SanityPost type for Sanity-sourced posts (matches query projection)
- Add discriminated union type: `PostData = { source: 'sanity'; post: SanityPost } | { source: 'markdown'; post: BlogPost }`

Rewrite `src/routes/[slug]/+page.server.ts`:

```typescript
import type { PageServerLoad } from './$types';
import { client } from '$lib/sanity/client';
import { postBySlugQuery } from '$lib/sanity/queries';
import { importPostBySlug } from '$lib/server/posts';
import { error } from '@sveltejs/kit';

export const load: PageServerLoad = async ({ params, url }) => {
    // Check for preview mode
    const isPreview = url.searchParams.get('preview') === 'secret123'; // TODO: use env var
    const sanityClient = isPreview ? previewClient : client;

    // Try Sanity first
    try {
        const sanityPost = await sanityClient.fetch(postBySlugQuery, { slug: params.slug });

        if (sanityPost) {
            return {
                source: 'sanity' as const,
                post: sanityPost,
            };
        }
    } catch (e) {
        // Per CONTEXT.md: API failure shows error, don't silently fall back
        console.error('Sanity fetch failed:', e);
        throw error(503, 'Content service unavailable');
    }

    // Fall back to markdown
    try {
        const mdPost = await importPostBySlug(params.slug);
        return {
            source: 'markdown' as const,
            post: mdPost,
        };
    } catch {
        throw error(404, 'Post not found');
    }
};
```

Note: The preview secret should come from environment variable SANITY_PREVIEW_SECRET. Add to
.env.example. </action> <verify>

- `npx tsc --noEmit` passes
- src/routes/[slug]/+page.server.ts imports from $lib/sanity/client
- src/lib/utils/types.ts exports PostData type </verify> <done> Route loader queries Sanity first,
  falls back to markdown, returns discriminated union with source field. </done> </task>

<task type="auto">
  <name>Task 2: Update [slug] page to render both sources</name>
  <files>src/routes/[slug]/+page.svelte</files>
  <action>
Update `src/routes/[slug]/+page.svelte` to handle both Sanity and markdown posts:

Key changes:

1. Import PortableText from @portabletext/svelte
2. Import portableTextComponents from $lib/sanity/portable-text
3. Import urlFor, generateSrcSet from $lib/sanity/image
4. Check data.source to determine rendering path

For source === 'sanity':

- Use PortableText component with portableTextComponents for body
- Generate cover image srcset from Sanity CDN using urlFor
- Map tags from Sanity format (array of {name, slug}) to display
- Author comes pre-dereferenced from query

For source === 'markdown':

- Keep existing rendering logic (component render)
- Keep existing cover image handling

Shared parts:

- Title, date, reading time layout stays same
- Tags rendering (normalize format)
- Related posts section (same-source only per CONTEXT.md - can skip related for Sanity in this
  phase)

Template structure:

```svelte
{#if data.source === 'sanity'}
    <!-- Sanity-specific rendering -->
    {#if data.post.coverImage}
        <img
            src={urlFor(data.post.coverImage).width(1280).auto('format').url()}
            srcset={generateSrcSet(data.post.coverImage)}
            alt={data.post.coverImage.alt}
            style:background-image={data.post.coverImage.lqip
                ? `url(${data.post.coverImage.lqip})`
                : undefined}
        />
    {/if}
    <div class="content">
        <PortableText value={data.post.body} components={portableTextComponents} />
    </div>
{:else}
    <!-- Existing markdown rendering -->
    {@const Post = data.post.content}
    <Post />
{/if}
```

Ensure article structure, header, metadata display works for both. </action> <verify>

- `npm run check` passes
- Page imports PortableText and portableTextComponents
- Conditional rendering based on data.source </verify> <done> Blog post page renders Sanity posts
  with Portable Text components and markdown posts with existing component rendering. </done>
  </task>

<task type="auto">
  <name>Task 3: Create merged blog listing</name>
  <files>src/routes/blog/+page.server.ts</files>
  <action>
Update `src/routes/blog/+page.server.ts` to merge Sanity and markdown posts:

```typescript
import type { PageServerLoad } from './$types';
import type { MetaTagsProps } from 'svelte-meta-tags';
import { client } from '$lib/sanity/client';
import { allPostsQuery } from '$lib/sanity/queries';
import { filteredPosts as markdownPosts } from '$lib/server/posts';

export const load: PageServerLoad = async () => {
    // Fetch from Sanity
    let sanityPosts = [];
    try {
        sanityPosts = await client.fetch(allPostsQuery);
    } catch (e) {
        console.error('Sanity fetch failed:', e);
        // Continue with markdown-only if Sanity fails
    }

    // Normalize Sanity posts to match listing shape
    const normalizedSanityPosts = sanityPosts.map((p) => ({
        ...p,
        source: 'sanity' as const,
        tags: p.tags?.map((t) => t.name) ?? [], // Flatten to string array for display
    }));

    // Deduplicate: Sanity wins for matching slugs
    const sanitySlugSet = new Set(normalizedSanityPosts.map((p) => p.slug));
    const mdFiltered = markdownPosts
        .filter((p) => !sanitySlugSet.has(p.slug))
        .map((p) => ({ ...p, source: 'markdown' as const }));

    // Merge and sort by date descending
    const allPosts = [...normalizedSanityPosts, ...mdFiltered].sort(
        (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
    );

    const pageMetaTags = Object.freeze({
        title: 'Blog',
        description: 'DevOps insights, cloud infrastructure tutorials...',
        // ... keep existing meta tags
    }) satisfies MetaTagsProps;

    return {
        posts: allPosts,
        pageMetaTags,
    };
};
```

Note: For listing, we normalize tags to string[] for display consistency. The source field enables
future differentiation if needed. </action> <verify>

- `npm run check` passes
- blog/+page.server.ts imports from $lib/sanity/client
- blog/+page.server.ts imports allPostsQuery </verify> <done> Blog listing merges posts from both
  sources, deduplicates by slug (Sanity wins), sorts by date descending. </done> </task>

</tasks>

<verification>
After all tasks complete:

1. Run type check: `npm run check` passes
2. Run tests: `npm test` passes
3. Start dev server: `npm run dev`
4. Verify routes load without error:
    - Visit /blog - should show merged listing
    - Visit existing markdown post slug - should render from markdown
    - (After migration in Plan 04) Visit Sanity post slug - should render from Sanity
      </verification>

<success_criteria>

- [slug] route queries Sanity first, falls back to markdown
- [slug] page renders Sanity posts with Portable Text
- [slug] page renders markdown posts with existing component
- Blog listing merges and deduplicates posts from both sources
- TypeScript compilation passes
- Existing markdown posts continue to work </success_criteria>

<output>
After completion, create `.planning/phases/02-vertical-slice/02-03-SUMMARY.md`
</output>
